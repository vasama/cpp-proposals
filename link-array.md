---
title: "Link-time merging of arrays"
document: D0xxxR0
date: today
audience: Language Evolution Group
author:
  - name: Lauri Vasama
    email: <wg21@vasama.org>
toc: true
---

# Introduction

This paper proposes a new method of defining arrays in namespace scope by merging one or more variables or arrays of the same type together from all translation units.

# Motivation

It is often desirable to statically define sets of things in a distributed manner without explicitly and manually maintaining the full list of elements in a single location. In C++20 the only way to achieve this is by building the set at runtime using static initialisers. This approach however presents multiple problems:

* Accessing specific elements adds additional complexity. For example storing indices in global variables during static initialisation.
* Is subject to the static initialisation order fiasco if other static initialisers should access the list, even when the actual data is known statically and could in theory be constant initialised.
* Use in certain domains such as embedded firmware poses challenges: data must either be stored in a linked list or some form of dynamic allocation is required.
* Adds unnecessary runtime overhead in both time and memory.
* Is made fragile due to the fact that static initialisers - even when they have side effects - are not always executed if the objects they initialise are never used.
  Ironically this also works the other way around: static initialisers with side effects cannot be elided when their effects, i.e. the set they build at runtime, are not actually being used.

Some existing use cases:
* Test case registration in all major C++ unit test frameworks.
* Optimisation pass registration in LLVM.
* Type information registration in Unreal Engine.
* Multiple tables in iPXE (C language) created using linker sections.

Collation of type information may become a particularly important use case if static reflection is added to the language. A reflection library may register descriptions of user types and other entities in link arrays for runtime use.

::: tonytable

### Before
```cpp
std::vector<int>& get_array_as_vector() {
  static std::vector<T> vector;
  return vector;
}

std::span<int const> get_array() {
  return get_array_as_vector();
}


static char const elements_pusher = (
  get_array_as_vector().push_back(value_0),
  get_array_as_vector().push_back(value_1),
  0 /* Value used to initialize char elements_pusher. */);
```

### After
```cpp
extern int const array[];

std::span<int const> get_array() {
  return std::span(array, std::link_array_size(array));
}


register(array)
static int const elements[] = { value_0, value_1 };
```
:::

# Design considerations

## Defining elements of link arrays



## Link array element ordering

* All elements of a link array defined within a single translation unit are ordered in the resulting array according to their definitions.
* The relative ordering of elements from different translation units is unspecified, but same for all link arrays. This facilitates the definition of parallel link arrays.

## Size of the merged array

There are at least two alternative approaches for exposing the size of the merged array with different pros and cons:

::: tonytable

### Library function template taking a pointer.

Usage:
```cpp
std::link_array_size(array)
```

* Illegal usage has undefined behaviour at runtime.
* Reference to the array may be a runtime value.
* Lesser implementation flexibility.

Possible implementation:
```cpp
// The size of the array might be stored before the array in memory.
template<typename Element>
size_t link_array_size(Element const* const array) noexcept {
  return __link_array_size(array);
}
```

### Library function template with array reference NTTP.

Usage:
```cpp
std::link_array_size<array>()
```

* Illegal usage may produce an error at link time.
* Reference to the array must be a constexpr value.
* Greater implementation flexibility.

Possible implementation:
```cpp
// The size might be calculated by subtraction of pointers to end and begin symbols generated by the linker.
template<__link_array_reference auto const& Array>
size_t link_array_size() noexcept {
  return __link_array_end(Array) - __link_array_begin(Array);
}
```
:::

## Implementability

Existing linkers already support merging symbols into arrays from multiple translation units in order to implement static initialisers, thread local storage and exception handling.

# Examples

## Unit test framework

The example code is simplified for readability. A real unit test framework would likely use macros to hide any boilerplate code.

Framework header:
```cpp
using test_case_callback = void();

// array of test case callbacks
extern test_case_callback* const test_cases[];
```

User test code:
```cpp
register(test_cases)
test_case_callback* const my_test_case = my_test_case_function_1;

register(test_cases)
test_case_callback* const my_test_case_array[] = {
  my_test_case_function_2,
  my_test_case_function_3
};
```

Framework source:
```cpp
void run_unit_tests()
{
  test_case_callback* const* const tests = test_cases;
  size_t const test_count = std::link_array_size(tests);

  for (test_case_callback* const test : std::span(tests, test_count))
  {
      test();
  }
}
```
